###############################################################################
#
# thesplit - An API server to support the secure sharing of secrets.
# Copyright (c) 2016  Glenn Rempe
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
###############################################################################

class SecretsController < ApplicationController
  post '/' do
    Stats.store('views/api/v1/secrets', count: 1, post: 1)

    # ID is 16 byte hash of the data that was stored
    param :id, String, required: true, min_length: 32, max_length: 32,
                       format: settings.hex_regex

    param :boxNonceB64, String, required: true, min_length: 24, max_length: 64,
                                format: settings.base64_regex

    param :boxB64, String, required: true, min_length: 1,
                           max_length: settings.secrets_max_length,
                           format: settings.base64_regex

    param :scryptSaltB64, String, required: true, min_length: 24, max_length: 64,
                                  format: settings.base64_regex

    # Differentiate between the client_hash_id and the server_hash_id.
    # The client hash is the hash of the contents generated by the client
    # and used as the client ID for requesting a secret.
    #
    # The server_hash_id is just the SHA256(client_hash_id) and is what is
    # used on the server side to store and find secrets.
    #
    # This simple step is taken help prevent reversing of the server storeage
    # key back to its original client ID. This prevents an attacker who gains
    # control of a DB dump from being able to search for that ID globally
    # (e.g. searching all email, or all Twitter, etc.) in order to
    # learn something about who has held that key ID. A small step
    # towards protecting the anonymity of the creator.
    #
    client_hash_id  = params['id']
    server_hash_id  = Digest::SHA256.hexdigest(client_hash_id)

    scrypt_salt_b64 = params['scryptSaltB64']
    box_nonce_b64   = params['boxNonceB64']
    box_b64         = params['boxB64']

    t     = Time.now
    t_exp = t + settings.secrets_expire_in
    key   = secret_storage_redis_key(server_hash_id)

    unless $redis.get(key).blank?
      halt 409, error_json('Data conflict, secret with ID already exists', 409)
    end

    obj = { boxNonceB64: box_nonce_b64,
            boxB64: box_b64,
            scryptSaltB64: scrypt_salt_b64 }

    $redis.set(key, obj.to_json)
    $redis.expire(key, settings.secrets_expire_in)

    # Generate a hash of the entire object stored in the DB for this secret
    # and send it to the blockchain for storage. Send the server_hash_id as
    # well to allow later lookup and random verification that what is stored
    # in a record is still what is there and recorded on the blockchain.
    BlockchainSendHashWorker.perform_async(server_hash_id, ObjectHash.hexdigest(obj))

    return success_json(id: client_hash_id, createdAt: t.utc.iso8601,
                        expiresAt: t_exp.utc.iso8601)
  end

  options '/' do
    response.headers['Allow'] = 'POST'
    200
  end

  delete '/:id' do
    Stats.store('views/api/v1/secrets/id', count: 1)

    # ID is 16 byte hash of the data that was stored
    param :id, String, required: true, min_length: 32, max_length: 32,
                       format: settings.hex_regex

    client_hash_id = params['id']
    key = secret_storage_redis_key(Digest::SHA256.hexdigest(client_hash_id))
    $redis.del(key)

    return success_json
  end

  get '/:id' do
    Stats.store('views/api/v1/secrets/id', count: 1)

    # ID is the 16 byte hash of the data that was stored
    param :id, String, required: true, min_length: 32, max_length: 32,
                       format: settings.hex_regex

    client_hash_id = params['id']
    key = secret_storage_redis_key(Digest::SHA256.hexdigest(client_hash_id))
    sec_json = $redis.get(key)

    raise Sinatra::NotFound if sec_json.blank?

    begin
      sec = JSON.parse(sec_json)
    rescue StandardError
      halt 500, error_json('Fatal error, corrupt data, JSON', 500)
    ensure
      # Always delete found data immediately on first view,
      # even if the parse fails.
      $redis.del(key)
    end

    return success_json(sec)
  end

  options '/:id' do
    response.headers['Allow'] = 'GET,DELETE'
    200
  end
end
